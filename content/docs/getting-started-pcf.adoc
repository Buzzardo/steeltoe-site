+++
date = "2016-06-01T17:07:31-06:00"
title = "Getting Started with Steel Toe and Spring Cloud Services for Pivotal Cloud Foundry"

+++

This page shows how to quickly set up the Steel Toe Configuration extension in an ASP.NET Core application for accessing configuration values served by a https://network.pivotal.io/products/p-spring-cloud-services[Spring Cloud Services] Config Server service instance on https://network.pivotal.io/products/pivotal-cf[Pivotal Cloud Foundry]&reg;.

To follow these instructions, you will need access to a Pivotal Cloud Foundry environment. We will be using https://run.pivotal.io[Pivotal Web Services] (PWS); if you don't have an account there, go ahead and create one before proceeding. You will also need to have the https://github.com/cloudfoundry/cli[cf Command Line Interface tool] installed.

=== Step 0: Create a Config Server service instance

Using the cf CLI, log into PWS and target your preferred org and space.

```
> cf target -o myorg -s development

API endpoint:   https://api.run.pivotal.io (API version: 2.57.0)
User:           user
Org:            myorg
Space:          development

```

Create a Config Server service instance, using the `-c` flag to provide parameters that configure the instance. The only parameter we'll need is a Git repository URI; as shown below, give the URI `https://github.com/SteelToeOSS/config-repo`:

```
> cf create-service p-config-server standard config-server -c "{\"git\": {\"uri\": \"https://github.com/SteelToeOSS/config-repo\" } }"
Creating service instance config-server in org myorg / space development as user...
OK

Create in progress. Use 'cf services' or 'cf service config-server' to check operation status.
```

When the service instance has been created, the command `cf service config-server` will return `Status: create succeeded`:

```
> cf service config-server

Service instance: config-server

...

Last Operation
Status: create succeeded
Message:
Started: 2016-07-13T16:36:13Z
Updated: 2016-07-13T16:37:19Z

```

=== Step 1: Add the Steel Toe Configuration dependency

https://docs.asp.net/en/latest/client-side/yeoman.html[Generate] a new ASP.NET Core application using Yeoman. When the generator asks what type of application you want to create, select the "Web Application Basic [without Membership and Authorization]" option. For our example purposes, call the application &#8220;Foo&#8221;. Then create a `nuget.config` file, and within it, list the Steel Toe feeds:

```
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="SteelToeMaster" value="https://www.myget.org/F/steeltoemaster/api/v3/index.json" />
    <add key="SteelToeDev" value="https://www.myget.org/F/steeltoedev/api/v3/index.json" />
    <add key="NuGet" value="https://api.nuget.org/v3/index.json" />
  </packageSources>
</configuration>
```

In the `dependencies` block of our `project.json` file, add the `Pivotal.Extensions.Configuration.ConfigServer` dependency:

```
  "dependencies": {
    ...
    "Microsoft.VisualStudio.Web.BrowserLink.Loader": "14.0.0",
    "Pivotal.Extensions.Configuration.ConfigServer": "1.0.0-dev-*"
  },
```

=== Step 1.5:

Create a Cloud Foundry manifest for our application. It should be a file called `manifest.yml` and should look like so:

```
---
applications:
- name: foo
  memory: 512M
  random-route: true
  path: publish
  buildpack: https://github.com/cloudfoundry-community/asp.net5-buildpack.git
  services:
    - config-server
```

This sets up our application to use the Config Server service instance we've created and to use the https://github.com/cloudfoundry-community/asp.net5-buildpack.git[cloudfoundry-community/dotnet-core-buildpack]. (It also uses `random-route` to give our application a unique route and avoid conflicts with any similarly-named applications' routes.)

=== Step 2: Configure the Config Server settings

Next, open `appsettings.json`. We need to specify a setting for Steel Toe Configuration to request our application's specific configuration from the Config Server:

```
{
  "spring": {
    "application": {
      "name": "foo"
    },
    "cloud": {
      "config": {
        "uri": "http://localhost:8888"
      }
    }
  },
...
}

```

Spring Cloud commonly uses `spring.application.name` to identify client applications. In the case of the Config Server, the files in the Config Server's Git or Subversion repository will include application names in their filenames, and the Server uses `spring.application.name` to determine which files in its repository contain configuration for our application.

The other property, `spring.cloud.config.uri`, is optional in our case. This tells a Steel Toe Configuration client application where to locate its Config Server. We give this a value of `http://localhost:8888` (the default port on which a Spring Cloud Config Server runs). As we'll soon see, however, this will be overridden when we bring in the Cloud Foundry Config Server, in:

=== Step 3: Add the Config Server configuration provider

In the constructor of our `Startup.cs`, where we use the `ConfigurationBuilder`, we need to add the Config Server as a configuration source.

```
using SteelToe.Extensions.Configuration.CloudFoundry;
using Pivotal.Extensions.Configuration;

namespace Foo
{
    public class Startup
    {
        public Startup(IHostingEnvironment env)
        {
            var builder = new ConfigurationBuilder()
                .SetBasePath(env.ContentRootPath)
                .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
                .AddJsonFile($"appsettings.{env.EnvironmentName}.json", optional: true)
                .AddEnvironmentVariables()

                .AddConfigServer(env);
            Configuration = builder.Build();
        }
```

Don't forget the `using` statements at the top. In fact, take special note of the first `using` statement. Steel Toe's Cloud Foundry configuration provider parses the special `VCAP_APPLICATION` and `VCAP_SERVICES` environment variables provided to Cloud Foundry applications. When we push this application to PWS, `VCAP_APPLICATION` will be set to contain application information (such as our application's space name, space ID, URIs, host, and port), and `VCAP_SERVICES` will be set to contain information for the services that are bound to the application (including a service instance's name, plan, tags, and connection information).

The connection information for our Config Server service instance, once it's made available to our application via the environment variables, will override what we specified in our `appsettings.json`. That setting is still useful to have for running an application locally against a local Config Server, but since we've placed the environment variables configuration provider higher in priority than `appsettings.json` (it's added _after_ `appsettings.json`), the information from the environment will override our hard-coded setting.

With the provider in place, we'll next add the Config Server to the set of services that we set up in the `ConfigureServices()` method.

```
        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddConfigServer(Configuration);

            // Add framework services.
            services.AddMvc();
        }
```

The `AddConfigServer()` method also takes care of adding the `IOptions` service and adds `IConfigurationRoot` as a service. This will become important in the next step, which is...

=== Step 4: Use configuration in the application

Open our `HomeController.cs` file. We need to give this controller an `IConfigurationRoot` property and a constructor to proceed further:

```
using SteelToe.Extensions.Configuration.CloudFoundry;
using Pivotal.Extensions.Configuration.ConfigServer;
using Microsoft.Extensions.Configuration;

namespace Foo.Controllers
{
    public class HomeController : Controller
    {

        private IConfigurationRoot Config { get; set; }

        public HomeController(IConfigurationRoot config)
        {
            Config = config;
        }
```

(Again, don't forget the `using` statements.)

We now have access to our configuration within the controller (the `Config` property). Next, let's add a `ConfigServer()` action. This action's view will display the value of a configuration property that we obtain from the Config Server, so let's set that value here:

```
        public IActionResult ConfigServer()
        {
            ViewData["Foo"] = Config["Foo"];
            return View();
        }
```

Create the `ConfigServer.cshtml` view in `Views/Home/`. It should look like this:

```
<h2>Configuration from the Spring Cloud Config Server</h2>

<p>Here is the value.</p>

<table width="50%">
  <tr>
    <th>Property</th>
    <th>Value</th>
  </tr>
  <tr>
    <th><em>Foo</em></td>
    <th><em>@ViewData["Foo"]</em></td>
  </tr>
</table>
```

=== Step 5: Voila!

That's it! Run `dotnet restore` to install all of our dependencies, then publish the application and push it to PWS:

```
Foo> dotnet restore
...
Feeds used:
    https://www.myget.org/F/steeltoemaster/api/v3/index.json
    https://www.myget.org/F/steeltoedev/api/v3/index.json
    https://api.nuget.org/v3/index.json
> dotnet publish --output publish --configuration Release --framework netcoreapp1.0 --runtime ubuntu.14.04-x64
Publishing Foo for .NETCoreApp,Version=v1.0
...
Published 1/1 projects successfully
> cf push
...

0 of 1 instances running, 1 starting
1 of 1 instances running

App started

...

     state     since                    cpu    memory      disk      details
#0   running   2016-07-14 03:24:25 PM   0.0%   0 of 512M   0 of 1G
```

And in a browser, visit the path `/Home/ConfigServer` on the application. You should see something like this:

image::/img/getting-started/configuration-pcf.png[]


